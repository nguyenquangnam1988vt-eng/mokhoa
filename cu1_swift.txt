import CoreLocation
import CoreMotion
import UIKit
import UserNotifications
import Flutter
import Network
import SystemConfiguration
import CoreTelephony
import AVFoundation

// üéØ CLASS CALL DETECTOR CHO CU·ªòC G·ªåI DI ƒê·ªòNG
class CallDetectorManager: NSObject {
    private let callCenter = CTCallCenter()
    private var isInCall = false
    private var callStartTime: Date?
    
    var onCallStateChanged: ((Bool, String) -> Void)?
    
    func startMonitoring() {
        callCenter.callEventHandler = { [weak self] call in
            DispatchQueue.main.async {
                self?.handleCallEvent(call: call)
            }
        }
    }
    
    private func handleCallEvent(call: CTCall) {
        let previousCallState = isInCall
        
        switch call.callState {
        case CTCallStateIncoming:
            print("üìû CU·ªòC G·ªåI ƒê·∫æN: \(call.callID ?? "Unknown")")
            // Ch∆∞a set isInCall = true v√¨ ch∆∞a nh·∫•c m√°y
            
        case CTCallStateConnected:
            print("üìû ƒê√É NH·∫§C M√ÅY - B·∫ÆT ƒê·∫¶U CU·ªòC G·ªåI")
            isInCall = true
            callStartTime = Date()
            onCallStateChanged?(true, "connected")
            
        case CTCallStateDisconnected:
            print("üìû ƒê√É K·∫æT TH√öC CU·ªòC G·ªåI")
            isInCall = false
            callStartTime = nil
            onCallStateChanged?(false, "disconnected")
            
        default:
            break
        }
        
        print("üìû Call State: \(call.callState) - isInCall: \(isInCall)")
    }
    
    func isCurrentlyInCall() -> Bool {
        return isInCall
    }
    
    func getCallDuration() -> TimeInterval? {
        guard let startTime = callStartTime else { return nil }
        return Date().timeIntervalSince(startTime)
    }
}

// üéØ CLASS VOIP CALL DETECTOR CHO ZALO/FACEBOOK
class VoIPCallDetector: NSObject {
    private let audioSession = AVAudioSession.sharedInstance()
    private var isInVoIPCall = false
    private var voipCallStartTime: Date?
    private var lastAudioRoute: String = ""
    
    var onVoIPCallStateChanged: ((Bool, String) -> Void)?
    
    func startMonitoring() {
        // L·∫Øng nghe thay ƒë·ªïi audio route
        NotificationCenter.default.addObserver(self,
            selector: #selector(audioRouteChanged),
            name: AVAudioSession.routeChangeNotification,
            object: nil)
        
        // L·∫Øng nghe thay ƒë·ªïi audio session
        NotificationCenter.default.addObserver(self,
            selector: #selector(audioSessionInterrupted),
            name: AVAudioSession.interruptionNotification,
            object: nil)
        
        print("üì± VoIP Call Detector started")
    }
    
    func stopMonitoring() {
        NotificationCenter.default.removeObserver(self)
    }
    
    @objc private func audioRouteChanged(notification: Notification) {
        DispatchQueue.main.async {
            self.checkCurrentAudioState()
        }
    }
    
    @objc private func audioSessionInterrupted(notification: Notification) {
        guard let userInfo = notification.userInfo,
              let interruptionType = userInfo[AVAudioSessionInterruptionTypeKey] as? UInt else { return }
        
        DispatchQueue.main.async {
            if interruptionType == AVAudioSession.InterruptionType.began.rawValue {
                // Cu·ªôc g·ªçi b·∫Øt ƒë·∫ßu
                self.handleVoIPCallStarted()
            } else if interruptionType == AVAudioSession.InterruptionType.ended.rawValue {
                // Cu·ªôc g·ªçi k·∫øt th√∫c
                self.handleVoIPCallEnded()
            }
        }
    }
    
    private func checkCurrentAudioState() {
        let currentRoute = audioSession.currentRoute
        
        // üéØ PH√ÅT HI·ªÜN CU·ªòC G·ªåI VoIP D·ª∞A TR√äN AUDIO ROUTE
        let isLikelyInVoIPCall = isAudioRouteIndicatingCall(currentRoute)
        
        if isLikelyInVoIPCall && !isInVoIPCall {
            handleVoIPCallStarted()
        } else if !isLikelyInVoIPCall && isInVoIPCall {
            handleVoIPCallEnded()
        }
        
        lastAudioRoute = describeAudioRoute(currentRoute)
    }
    
    private func isAudioRouteIndicatingCall(_ route: AVAudioSessionRouteDescription) -> Bool {
        // Ki·ªÉm tra xem audio route c√≥ ch·ªâ ra ƒëang trong cu·ªôc g·ªçi kh√¥ng
        let hasMicrophone = route.inputs.contains { $0.portType == .builtInMic }
        let hasReceiver = route.outputs.contains { $0.portType == .builtInReceiver }
        let hasSpeaker = route.outputs.contains { $0.portType == .builtInSpeaker }
        let hasHeadphones = route.outputs.contains { $0.portType == .headphones }
        
        // üéØ C√ÅC T√åNH HU·ªêNG CHO TH·∫§Y ƒêANG TRONG CU·ªòC G·ªåI VOIP:
        // 1. C√≥ mic + receiver (√°p tai nghe) - Zalo/Facebook call
        // 2. C√≥ mic + speaker (loa ngo√†i) - Zalo/Facebook call loa ngo√†i
        // 3. C√≥ mic + headphones (tai nghe) - Zalo/Facebook call tai nghe
        let isInCall = hasMicrophone && (hasReceiver || hasSpeaker || hasHeadphones)
        
        print("üéß VoIP Audio Route - Mic: \(hasMicrophone), Receiver: \(hasReceiver), Speaker: \(hasSpeaker) -> InCall: \(isInCall)")
        return isInCall
    }
    
    private func handleVoIPCallStarted() {
        isInVoIPCall = true
        voipCallStartTime = Date()
        
        let callType = determineCallType()
        onVoIPCallStateChanged?(true, callType)
        
        print("üì± VoIP Call STARTED: \(callType)")
    }
    
    private func handleVoIPCallEnded() {
        isInVoIPCall = false
        voipCallStartTime = nil
        onVoIPCallStateChanged?(false, "ended")
        
        print("üì± VoIP Call ENDED")
    }
    
    private func determineCallType() -> String {
        let currentRoute = audioSession.currentRoute
        
        if currentRoute.outputs.contains(where: { $0.portType == .builtInReceiver }) {
            return "voip_ear" // G·ªçi √°p tai
        } else if currentRoute.outputs.contains(where: { $0.portType == .builtInSpeaker }) {
            return "voip_speaker" // G·ªçi loa ngo√†i
        } else if currentRoute.outputs.contains(where: { $0.portType == .headphones }) {
            return "voip_headphones" // G·ªçi tai nghe
        } else {
            return "voip_unknown"
        }
    }
    
    private func describeAudioRoute(_ route: AVAudioSessionRouteDescription) -> String {
        let inputs = route.inputs.map { $0.portType.rawValue }.joined(separator: ", ")
        let outputs = route.outputs.map { $0.portType.rawValue }.joined(separator: ", ")
        return "Inputs: [\(inputs)], Outputs: [\(outputs)]"
    }
    
    func isCurrentlyInVoIPCall() -> Bool {
        return isInVoIPCall
    }
    
    func getVoIPCallDuration() -> TimeInterval? {
        guard let startTime = voipCallStartTime else { return nil }
        return Date().timeIntervalSince(startTime)
    }
}

@objcMembers
class UnlockMonitor: NSObject, CLLocationManagerDelegate, FlutterStreamHandler {
    
    private var locationManager: CLLocationManager?
    private var motionManager: CMMotionManager?
    private var networkMonitor: NWPathMonitor?
    private var eventSink: FlutterEventSink?
    private var isDeviceUnlocked = false
    private var currentSpeed: Double = 0.0
    private var isDriving = false
    private var isNetworkActive = false
    private var lastDangerAlertTime: Date?
    
    // üéØ NETWORK DETECTION TH√îNG MINH
    private var networkCongestionDetector: NetworkCongestionDetector?
    private var realNetworkMonitor: RealNetworkMonitor?
    private var isActiveBrowsing = false
    
    // üéØ C·∫¢I THI·ªÜN T·ªêC ƒê·ªò - C·∫¨P NH·∫¨T TH∆Ø·ªúNG XUY√äN
    private var lastValidLocation: CLLocation?
    private var speedUpdateTimer: Timer?
    private var lastSpeedUpdateTime: Date = Date()
    
    // üéØ TH√äM CALL DETECTION
    private var callDetector: CallDetectorManager?
    private var isInCall = false
    private var callStartTime: Date?
    private var lastCallAlertTime: Date?
    private let callAlertCooldown: TimeInterval = 10.0 // 10 gi√¢y gi·ªØa c√°c c·∫£nh b√°o call
    
    // üìû TH√äM VOIP DETECTION
    private var voipCallDetector: VoIPCallDetector?
    private var isInVoIPCall = false
    private var voipCallStartTime: Date?
    private var lastVoIPAlertTime: Date?
    private let voipAlertCooldown: TimeInterval = 10.0 // 10 gi√¢y gi·ªØa c√°c c·∫£nh b√°o VoIP
    
    // Ng∆∞·ª°ng
    private let drivingSpeedThreshold: Double = 10.0 // km/h
    private let viewingPhoneThreshold: Double = 80.0
    private let intermediateThreshold: Double = 90.0
    private let dangerAlertCooldown: TimeInterval = 5.0

    // Bi·∫øn theo d√µi ƒë·ªô ·ªïn ƒë·ªãnh tr·ª•c Z
    private var zAccelerationHistory: [Double] = []
    private let zStabilityBufferSize = 50
    private var zStability: Double = 0.0
    
    static let shared = UnlockMonitor()
    
    override init() {
        super.init()
        setupNetworkMonitoring()
        setupNetworkCongestionDetection()
        setupRealNetworkMonitoring()
        setupSpeedUpdateTimer()
        setupCallDetection()
        setupVoIPDetection() // üéØ TH√äM D√íNG N√ÄY
    }
    
    // MARK: - FlutterStreamHandler Methods
    
    public func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -> FlutterError? {
        self.eventSink = events
        print("Flutter EventChannel ƒë√£ k·∫øt n·ªëi")
        return nil
    }
    
    public func onCancel(withArguments arguments: Any?) -> FlutterError? {
        eventSink = nil
        speedUpdateTimer?.invalidate()
        print("Flutter EventChannel ƒë√£ ng·∫Øt k·∫øt n·ªëi")
        return nil
    }
    
    // MARK: - Monitoring Control
    
    func startMonitoring() {
        setupLocationMonitoring()
        setupTiltMonitoring()
        setupLockUnlockObservers()
        networkCongestionDetector?.startMonitoring()
        realNetworkMonitor?.startMonitoring()
        callDetector?.startMonitoring()
        voipCallDetector?.startMonitoring() // üéØ TH√äM D√íNG N√ÄY
        
        print("Unlock Monitor: ƒê√£ ƒëƒÉng k√Ω v√† b·∫Øt ƒë·∫ßu theo d√µi (bao g·ªìm call + VoIP detection).")
    }
    
    func stopMonitoring() {
        motionManager?.stopAccelerometerUpdates()
        locationManager?.stopUpdatingLocation()
        networkMonitor?.cancel()
        networkCongestionDetector?.stopMonitoring()
        realNetworkMonitor?.stopMonitoring()
        callDetector = nil
        voipCallDetector?.stopMonitoring() // üéØ TH√äM D√íNG N√ÄY
        voipCallDetector = nil
        speedUpdateTimer?.invalidate()
        NotificationCenter.default.removeObserver(self)
    }
    
    // üéØ TH√äM PH∆Ø∆†NG TH·ª®C VOIP DETECTION
    private func setupVoIPDetection() {
        voipCallDetector = VoIPCallDetector()
        voipCallDetector?.onVoIPCallStateChanged = { [weak self] isInCall, callType in
            guard let self = self else { return }
            
            let wasInVoIPCall = self.isInVoIPCall
            self.isInVoIPCall = isInCall
            
            if isInCall {
                self.voipCallStartTime = Date()
            } else {
                self.voipCallStartTime = nil
            }
            
            // G·ª≠i s·ª± ki·ªán VoIP call state t·ªõi Flutter
            let callTime = Date()
            let callData: [String: Any] = [
                "type": "VOIP_CALL_EVENT",
                "message": isInCall ? "ƒêang trong cu·ªôc g·ªçi Zalo/Facebook (\(callType))" : "ƒê√£ k·∫øt th√∫c cu·ªôc g·ªçi Zalo/Facebook",
                "isInCall": isInCall,
                "isVoIPCall": true,
                "callType": callType,
                "callDuration": self.voipCallDetector?.getVoIPCallDuration() ?? 0,
                "timestamp": Int(callTime.timeIntervalSince1970 * 1000)
            ]
            
            self.sendEventToFlutter(callData)
            print("üì± VoIP Call State: \(isInCall ? "ACTIVE" : "ENDED") - Type: \(callType)")
            
            // üö® KI·ªÇM TRA C·∫¢NH B√ÅO N·∫æU ƒêANG L√ÅI XE
            if isInCall && self.isDriving && !wasInVoIPCall {
                self.checkVoIPCallWhileDrivingAlert(callType: callType)
            }
        }
        
        voipCallDetector?.startMonitoring()
    }
    
    // üéØ TH√äM PH∆Ø∆†NG TH·ª®C CALL DETECTION
    private func setupCallDetection() {
        callDetector = CallDetectorManager()
        callDetector?.onCallStateChanged = { [weak self] isInCall, state in
            guard let self = self else { return }
            
            let wasInCall = self.isInCall
            self.isInCall = isInCall
            
            if isInCall {
                self.callStartTime = Date()
            } else {
                self.callStartTime = nil
            }
            
            // G·ª≠i s·ª± ki·ªán call state t·ªõi Flutter
            let callTime = Date()
            let callData: [String: Any] = [
                "type": "CALL_EVENT",
                "message": isInCall ? "ƒêang trong cu·ªôc g·ªçi ƒëi·ªán tho·∫°i" : "ƒê√£ k·∫øt th√∫c cu·ªôc g·ªçi",
                "isInCall": isInCall,
                "callState": state,
                "callDuration": self.getCallDuration() ?? 0,
                "timestamp": Int(callTime.timeIntervalSince1970 * 1000)
            ]
            
            self.sendEventToFlutter(callData)
            print("üìû Call State Changed: \(isInCall ? "IN_CALL" : "END_CALL") - State: \(state)")
            
            // üö® KI·ªÇM TRA C·∫¢NH B√ÅO N·∫æU ƒêANG L√ÅI XE V√Ä B·∫ÆT ƒê·∫¶U CU·ªòC G·ªåI
            if isInCall && self.isDriving && !wasInCall {
                self.checkCallWhileDrivingAlert()
            }
        }
        
        callDetector?.startMonitoring()
    }
    
    private func getCallDuration() -> TimeInterval? {
        guard let startTime = callStartTime else { return nil }
        return Date().timeIntervalSince(startTime)
    }
    
    // üéØ TIMER C·∫¨P NH·∫¨T T·ªêC ƒê·ªò TH∆Ø·ªúNG XUY√äN
    private func setupSpeedUpdateTimer() {
        speedUpdateTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            self?.sendSpeedUpdate()
        }
        RunLoop.current.add(speedUpdateTimer!, forMode: .common)
    }
    
    private func sendSpeedUpdate() {
        let speedData: [String: Any] = [
            "type": "SPEED_UPDATE",
            "speed": currentSpeed,
            "isDriving": isDriving,
            "timestamp": Int(Date().timeIntervalSince1970 * 1000)
        ]
        self.sendEventToFlutter(speedData)
    }
    
    // üéØ TH√äM H√ÄM KI·ªÇM TRA C·∫¢NH B√ÅO KHI NGHE ƒêI·ªÜN THO·∫†I L√ÅI XE
    private func checkCallWhileDrivingAlert() {
        guard canSendCallAlert() else { return }
        
        let dangerTime = Date()
        lastCallAlertTime = dangerTime
        
        let dangerData: [String: Any] = [
            "type": "DANGER_EVENT",
            "message": "C·∫¢NH B√ÅO NGUY HI·ªÇM: ƒêang l√°i xe v√† NGHE ƒêI·ªÜN THO·∫†I!",
            "speed": currentSpeed,
            "isInCall": true,
            "callDuration": getCallDuration() ?? 0,
            "timestamp": Int(dangerTime.timeIntervalSince1970 * 1000)
        ]
        
        self.sendEventToFlutter(dangerData)
        self.sendCriticalNotification(
            title: "C·∫¢NH B√ÅO NGUY HI·ªÇM!",
            message: "ƒêang l√°i xe ·ªü \(String(format: "%.1f", currentSpeed)) km/h v√† NGHE ƒêI·ªÜN THO·∫†I!"
        )
        
        print("üö® CALL DANGER ALERT: Driving + Phone Call! Speed: \(currentSpeed) km/h")
    }
    
    // üéØ TH√äM H√ÄM C·∫¢NH B√ÅO CHO VOIP CALL
    private func checkVoIPCallWhileDrivingAlert(callType: String) {
        guard canSendVoIPAlert() else { return }
        
        let dangerTime = Date()
        lastVoIPAlertTime = dangerTime
        
        let appName = getAppNameFromCallType(callType)
        let callDuration = voipCallDetector?.getVoIPCallDuration() ?? 0
        
        let dangerData: [String: Any] = [
            "type": "DANGER_EVENT",
            "message": "C·∫¢NH B√ÅO NGUY HI·ªÇM: ƒêang l√°i xe v√† G·ªåI \(appName)!",
            "speed": currentSpeed,
            "isInCall": true,
            "isVoIPCall": true,
            "callType": callType,
            "callDuration": callDuration,
            "timestamp": Int(dangerTime.timeIntervalSince1970 * 1000)
        ]
        
        self.sendEventToFlutter(dangerData)
        self.sendCriticalNotification(
            title: "C·∫¢NH B√ÅO NGUY HI·ªÇM!",
            message: "ƒêang l√°i xe ·ªü \(String(format: "%.1f", currentSpeed)) km/h v√† G·ªåI \(appName)!"
        )
        
        print("üö® VOIP CALL DANGER ALERT: Driving + \(appName) Call! Speed: \(currentSpeed) km/h, Duration: \(callDuration)s")
    }
    
    private func canSendCallAlert() -> Bool {
        guard let lastAlert = lastCallAlertTime else { return true }
        return Date().timeIntervalSince(lastAlert) >= callAlertCooldown
    }
    
    private func canSendVoIPAlert() -> Bool {
        guard let lastAlert = lastVoIPAlertTime else { return true }
        return Date().timeIntervalSince(lastAlert) >= voipAlertCooldown
    }
    
    private func getAppNameFromCallType(_ callType: String) -> String {
        return "ZALO/FACEBOOK"
    }
    
    // üéØ REAL NETWORK MONITORING TH√îNG MINH
    private func setupRealNetworkMonitoring() {
        realNetworkMonitor = RealNetworkMonitor()
        realNetworkMonitor?.onNetworkActivityDetected = { [weak self] isActive, activityType in
            guard let self = self else { return }
            
            let wasBrowsing = self.isActiveBrowsing
            self.isActiveBrowsing = isActive
            
            if wasBrowsing != isActive {
                let analysisTime = Date()
                let analysisData: [String: Any] = [
                    "type": "REAL_NETWORK_ANALYSIS",
                    "message": isActive ? "ƒêang c√≥ ho·∫°t ƒë·ªông web th·ª±c t·∫ø (\(activityType))" : "Kh√¥ng c√≥ ho·∫°t ƒë·ªông web",
                    "isActiveBrowsing": isActive,
                    "activityType": activityType,
                    "timestamp": Int(analysisTime.timeIntervalSince1970 * 1000)
                ]
                
                self.sendEventToFlutter(analysisData)
                print("üåê Real Network Detection: \(isActive ? "ACTIVE - \(activityType)" : "INACTIVE")")
            }
        }
    }
    
    private func setupNetworkCongestionDetection() {
        networkCongestionDetector = NetworkCongestionDetector()
        networkCongestionDetector?.onNetworkStatusUpdate = { [weak self] isBrowsing in
            guard let self = self else { return }
            
            if !self.isActiveBrowsing {
                let wasBrowsing = self.isActiveBrowsing
                self.isActiveBrowsing = isBrowsing
                
                if wasBrowsing != isBrowsing {
                    let analysisTime = Date()
                    let analysisData: [String: Any] = [
                        "type": "NETWORK_ANALYSIS",
                        "message": isBrowsing ? "ƒêang c√≥ ho·∫°t ƒë·ªông l∆∞·ªõt web" : "Kh√¥ng c√≥ ho·∫°t ƒë·ªông web",
                        "isActiveBrowsing": isBrowsing,
                        "timestamp": Int(analysisTime.timeIntervalSince1970 * 1000)
                    ]
                    
                    self.sendEventToFlutter(analysisData)
                    print("üìä Network Analysis: Browsing: \(isBrowsing)")
                }
            }
        }
    }
    
    // MARK: - Network Monitoring
    
    private func setupNetworkMonitoring() {
        networkMonitor = NWPathMonitor()
        let queue = DispatchQueue(label: "NetworkMonitor")
        
        networkMonitor?.pathUpdateHandler = { [weak self] path in
            guard let self = self else { return }
            
            let wasNetworkActive = self.isNetworkActive
            self.isNetworkActive = (path.status == .satisfied)
            
            if wasNetworkActive != self.isNetworkActive {
                let networkTime = Date()
                let networkData: [String: Any] = [
                    "type": "NETWORK_STATUS",
                    "message": self.isNetworkActive ? "ƒê√£ k·∫øt n·ªëi Internet" : "M·∫•t k·∫øt n·ªëi Internet",
                    "isNetworkActive": self.isNetworkActive,
                    "timestamp": Int(networkTime.timeIntervalSince1970 * 1000)
                ]
                
                self.sendEventToFlutter(networkData)
                print("üåê Network Status: \(self.isNetworkActive ? "ACTIVE" : "INACTIVE")")
            }
        }
        
        networkMonitor?.start(queue: queue)
    }
    
    // MARK: - Location Monitoring - C·∫¢I THI·ªÜN ƒê·ªò CH√çNH X√ÅC
    
    private func setupLocationMonitoring() {
        if locationManager == nil {
            let manager = CLLocationManager()
            manager.delegate = self
            
            // üéØ S·ª¨ D·ª§NG GPS ƒê·ªò CH√çNH X√ÅC CAO
            manager.desiredAccuracy = kCLLocationAccuracyBestForNavigation
            manager.distanceFilter = 2.0 // Gi·∫£m ƒë·ªÉ c·∫≠p nh·∫≠t th∆∞·ªùng xuy√™n h∆°n
            manager.activityType = .automotiveNavigation
            manager.allowsBackgroundLocationUpdates = true
            manager.pausesLocationUpdatesAutomatically = false
            
            locationManager = manager
        }
        
        locationManager?.requestAlwaysAuthorization()
        
        let status = CLLocationManager.authorizationStatus()
        print("üìç Location Authorization Status: \(status.rawValue)")
        
        if status == .authorizedAlways || status == .authorizedWhenInUse {
            locationManager?.startUpdatingLocation()
            print("üìç ƒê√£ b·∫Øt ƒë·∫ßu c·∫≠p nh·∫≠t v·ªã tr√≠ v·ªõi ƒë·ªô ch√≠nh x√°c cao")
        } else {
            print("üìç Ch∆∞a c√≥ quy·ªÅn truy c·∫≠p v·ªã tr√≠")
        }
    }
    
    // MARK: - CLLocationManagerDelegate - T√çNH T·ªêC ƒê·ªò CHU·∫®N
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        
        // üéØ KI·ªÇM TRA ƒê·ªò CH√çNH X√ÅC C·ª¶A LOCATION
        guard location.horizontalAccuracy >= 0 && location.horizontalAccuracy <= 50.0 else {
            print("üìç B·ªè qua location - ƒë·ªô ch√≠nh x√°c k√©m: \(location.horizontalAccuracy)m")
            return
        }
        
        // üéØ T√çNH T·ªêC ƒê·ªò CHU·∫®N
        let calculatedSpeed = calculateAccurateSpeed(currentLocation: location)
        
        updateDrivingStatus(speed: calculatedSpeed)
        
        // üéØ TH√îNG B√ÅO CHO NETWORK MONITORS
        realNetworkMonitor?.notifyLocationUpdate()
        networkCongestionDetector?.setLocationUpdateCooldown()
        
        let locationData: [String: Any] = [
            "type": "LOCATION_UPDATE",
            "latitude": location.coordinate.latitude,
            "longitude": location.coordinate.longitude,
            "speed": currentSpeed,
            "accuracy": location.horizontalAccuracy,
            "isDriving": isDriving,
            "timestamp": Int(location.timestamp.timeIntervalSince1970 * 1000)
        ]
        
        self.sendEventToFlutter(locationData)
        lastSpeedUpdateTime = Date()
    }
    
    // üéØ T√çNH T·ªêC ƒê·ªò CHU·∫®N - ∆ØU TI√äN H·ªÜ TH·ªêNG
    private func calculateAccurateSpeed(currentLocation: CLLocation) -> Double {
        // üéØ PH∆Ø∆†NG PH√ÅP 1: S·ª≠ d·ª•ng t·ªëc ƒë·ªô t·ª´ h·ªá th·ªëng (∆∞u ti√™n)
        let systemSpeed = currentLocation.speed
        
        // üéØ KI·ªÇM TRA T√çNH H·ª¢P L·ªÜ C·ª¶A T·ªêC ƒê·ªò H·ªÜ TH·ªêNG
        if systemSpeed >= 0 && systemSpeed < 50.0 {
            // T·ªëc ƒë·ªô h·ªá th·ªëng h·ª£p l·ªá, s·ª≠ d·ª•ng tr·ª±c ti·∫øp
            print("üéØ Using system speed: \(systemSpeed * 3.6) km/h")
            return systemSpeed
        } else {
            // üéØ PH∆Ø∆†NG PH√ÅP 2: T√≠nh t·ª´ kho·∫£ng c√°ch
            let calculatedSpeed = calculateSpeedFromDistance(currentLocation: currentLocation)
            print("üéØ Using calculated speed: \(calculatedSpeed * 3.6) km/h")
            return calculatedSpeed
        }
    }
    
    private func calculateSpeedFromDistance(currentLocation: CLLocation) -> Double {
        guard let lastValidLocation = lastValidLocation else {
            lastValidLocation = currentLocation
            return 0.0
        }
        
        let distance = currentLocation.distance(from: lastValidLocation) // m√©t
        let time = currentLocation.timestamp.timeIntervalSince(lastValidLocation.timestamp) // gi√¢y
        
        // üéØ CH·ªà T√çNH KHI C√ì DI CHUY·ªÇN ƒê√ÅNG K·ªÇ V√Ä TH·ªúI GIAN H·ª¢P L·ªÜ
        guard time > 0 && distance >= 1.0 else {
            return 0.0
        }
        
        let speed = distance / time // m/s
        
        // üéØ KI·ªÇM TRA T·ªêC ƒê·ªò H·ª¢P L·ªÜ (0-50 m/s ‚âà 0-180 km/h)
        guard speed >= 0 && speed < 50.0 else {
            return 0.0
        }
        
        self.lastValidLocation = currentLocation
        return speed
    }
    
    // üéØ C·∫¨P NH·∫¨T TR·∫†NG TH√ÅI L√ÅI XE - TH∆Ø·ªúNG XUY√äN
    private func updateDrivingStatus(speed: Double) {
        let previousSpeed = currentSpeed
        currentSpeed = speed * 3.6 // Chuy·ªÉn sang km/h
        
        let wasDriving = isDriving
        isDriving = currentSpeed >= drivingSpeedThreshold
        
        // üéØ C·∫¨P NH·∫¨T TH∆Ø·ªúNG XUY√äN KHI ƒêANG DI CHUY·ªÇN
        if isDriving || abs(currentSpeed - previousSpeed) > 2.0 {
            let statusTime = Date()
            let statusData: [String: Any] = [
                "type": "DRIVING_STATUS",
                "message": isDriving ? 
                    "ƒêang l√°i xe ·ªü t·ªëc ƒë·ªô \(String(format: "%.1f", currentSpeed)) km/h" :
                    "ƒê√£ d·ª´ng/ƒëang ƒë·ª©ng y√™n",
                "speed": currentSpeed,
                "isDriving": isDriving,
                "timestamp": Int(statusTime.timeIntervalSince1970 * 1000)
            ]
            
            self.sendEventToFlutter(statusData)
            print("üéØ Driving status: \(isDriving ? "DRIVING" : "STOPPED") at \(currentSpeed) km/h")
            
            // üö® KI·ªÇM TRA C·∫¢NH B√ÅO N·∫æU B·∫ÆT ƒê·∫¶U L√ÅI XE KHI ƒêANG NGHE ƒêI·ªÜN THO·∫†I
            if isDriving && !wasDriving && (isInCall || isInVoIPCall) {
                if isInCall {
                    checkCallWhileDrivingAlert()
                }
                if isInVoIPCall {
                    let callType = voipCallDetector?.getVoIPCallDuration() != nil ? "voip_active" : "voip_unknown"
                    checkVoIPCallWhileDrivingAlert(callType: callType)
                }
            }
        }
    }
    
    // MARK: - Tilt Monitoring
    
    private func setupTiltMonitoring() {
        if motionManager == nil {
            motionManager = CMMotionManager()
        }
        
        guard let motionManager = motionManager else { return }
        
        guard motionManager.isAccelerometerAvailable else {
            print("Accelerometer kh√¥ng kh·∫£ d·ª•ng")
            return
        }
        
        motionManager.accelerometerUpdateInterval = 0.1
        
        motionManager.startAccelerometerUpdates(to: .main) { [weak self] (data, error) in
            guard let self = self else { return }
            
            if let error = error {
                print("L·ªói accelerometer: \(error.localizedDescription)")
                return
            }
            
            if let accelerometerData = data {
                let zAcceleration = accelerometerData.acceleration.z
                self.updateZStability(zValue: zAcceleration)
                self.handleTiltDetection(zValue: zAcceleration)
            }
        }
        
        print("ƒê√£ b·∫Øt ƒë·∫ßu theo d√µi c·∫£m bi·∫øn nghi√™ng")
    }
    
    private func updateZStability(zValue: Double) {
        zAccelerationHistory.append(zValue)
        if zAccelerationHistory.count > zStabilityBufferSize {
            zAccelerationHistory.removeFirst()
        }
        
        if zAccelerationHistory.count >= 2 {
            let mean = zAccelerationHistory.reduce(0, +) / Double(zAccelerationHistory.count)
            let variance = zAccelerationHistory.map { pow($0 - mean, 2) }.reduce(0, +) / Double(zAccelerationHistory.count)
            zStability = sqrt(variance)
        }
    }
    
    private func convertTiltToPercent(_ zValue: Double) -> Double {
        let tiltAbsolute = abs(zValue)
        let tiltPercent = (tiltAbsolute / 1.0) * 100.0
        return min(max(tiltPercent, 0.0), 100.0)
    }
    
    private func getTiltStatus(_ tiltPercent: Double) -> String {
        if tiltPercent <= viewingPhoneThreshold {
            return "üì± ƒêANG XEM"
        } else if tiltPercent < intermediateThreshold {
            return "‚ö° TRUNG GIAN"
        } else {
            return "üîº KH√îNG XEM"
        }
    }
    
    private func canSendDangerAlert() -> Bool {
        guard let lastAlert = lastDangerAlertTime else { return true }
        return Date().timeIntervalSince(lastAlert) >= dangerAlertCooldown
    }
    
    // üéØ C·∫¨P NH·∫¨T H√ÄM HANDLE TILT DETECTION - TH√äM 3 T√åNH HU·ªêNG C·∫¢NH B√ÅO
    private func handleTiltDetection(zValue: Double) {
        let tiltPercent = convertTiltToPercent(zValue)
        let tiltStatus = getTiltStatus(tiltPercent)
        let isViewingPhone = tiltPercent <= viewingPhoneThreshold
        let isZStable = zStability < 1.5
        
        // üö® C·∫¢NH B√ÅO 1: WEB BROWSING + L√ÅI XE
        let shouldTriggerWebDangerAlert = isDeviceUnlocked && 
                                         isDriving && 
                                         isViewingPhone && 
                                         isZStable &&
                                         isActiveBrowsing &&
                                         canSendDangerAlert()
        
        // üö® C·∫¢NH B√ÅO 2: CU·ªòC G·ªåI DI ƒê·ªòNG + L√ÅI XE
        let shouldTriggerCallDangerAlert = isDriving && 
                                          isInCall && 
                                          isZStable &&
                                          canSendCallAlert()
        
        // üö® C·∫¢NH B√ÅO 3: CU·ªòC G·ªåI ZALO/FACEBOOK + L√ÅI XE
        let shouldTriggerVoIPDangerAlert = isDriving && 
                                          isInVoIPCall && 
                                          isZStable &&
                                          canSendVoIPAlert()
        
        // K√çCH HO·∫†T C√ÅC C·∫¢NH B√ÅO
        if shouldTriggerWebDangerAlert {
            triggerWebDangerAlert(tiltPercent: tiltPercent, zValue: zValue)
        }
        
        if shouldTriggerCallDangerAlert {
            checkCallWhileDrivingAlert()
        }
        
        if shouldTriggerVoIPDangerAlert {
            let callType = voipCallDetector?.getVoIPCallDuration() != nil ? "voip_active" : "voip_unknown"
            checkVoIPCallWhileDrivingAlert(callType: callType)
        }
        
        let tiltTime = Date()
        let tiltData: [String: Any] = [
            "type": "TILT_EVENT",
            "message": "Thi·∫øt b·ªã: \(tiltStatus)",
            "tiltValue": zValue,
            "tiltPercent": tiltPercent,
            "speed": currentSpeed,
            "isNetworkActive": isNetworkActive,
            "isActiveBrowsing": isActiveBrowsing,
            "isInCall": isInCall,
            "isVoIPCall": isInVoIPCall,
            "zStability": zStability,
            "timestamp": Int(tiltTime.timeIntervalSince1970 * 1000)
        ]
        
        self.sendEventToFlutter(tiltData)
    }
    
    // üéØ T√ÅCH H√ÄM C·∫¢NH B√ÅO WEB TH√ÄNH RI√äNG
    private func triggerWebDangerAlert(tiltPercent: Double, zValue: Double) {
        let dangerTime = Date()
        lastDangerAlertTime = dangerTime
        
        let dangerData: [String: Any] = [
            "type": "DANGER_EVENT",
            "message": "C·∫¢NH B√ÅO NGUY HI·ªÇM: ƒêang l√°i xe v√† L∆Ø·ªöT WEB!",
            "tiltValue": zValue,
            "tiltPercent": tiltPercent,
            "speed": currentSpeed,
            "isNetworkActive": isNetworkActive,
            "isActiveBrowsing": isActiveBrowsing,
            "zStability": zStability,
            "timestamp": Int(dangerTime.timeIntervalSince1970 * 1000)
        ]
        
        self.sendEventToFlutter(dangerData)
        self.sendCriticalNotification(
            title: "C·∫¢NH B√ÅO NGUY HI·ªÇM!",
            message: "ƒêang l√°i xe ·ªü \(String(format: "%.1f", currentSpeed)) km/h, s·ª≠ d·ª•ng ƒëi·ªán tho·∫°i v√† L∆Ø·ªöT WEB!"
        )
        
        print("üö® WEB DANGER ALERT: Driving + Phone Usage + Web Browsing! (Tilt: \(tiltPercent)%)")
    }
    
    // MARK: - Lock/Unlock Observers
    
    private func setupLockUnlockObservers() {
        NotificationCenter.default.addObserver(self,
            selector: #selector(deviceDidUnlock),
            name: UIApplication.protectedDataDidBecomeAvailableNotification,
            object: nil)
        
        NotificationCenter.default.addObserver(self,
            selector: #selector(deviceDidLock),
            name: UIApplication.protectedDataWillBecomeUnavailableNotification,
            object: nil)
        
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound]) { granted, error in
            if let error = error {
                print("‚ùå Notification permission error: \(error)")
            } else {
                print("üîî Notification permission: \(granted ? "GRANTED" : "DENIED")")
            }
        }
    }
    
    @objc func deviceDidUnlock() {
        isDeviceUnlocked = true
        
        let unlockTime = Date()
        let unlockData: [String: Any] = [
            "type": "LOCK_EVENT",
            "message": "Thi·∫øt b·ªã v·ª´a ƒë∆∞·ª£c M·ªü Kh√≥a",
            "location": formatTime(unlockTime),
            "speed": currentSpeed,
            "isDriving": isDriving,
            "isInCall": isInCall,
            "isVoIPCall": isInVoIPCall,
            "timestamp": Int(unlockTime.timeIntervalSince1970 * 1000)
        ]
        
        self.sendEventToFlutter(unlockData)
        
        if isDriving {
            self.sendCriticalNotification(
                title: "C·∫¢NH B√ÅO!",
                message: "B·∫°n v·ª´a m·ªü kh√≥a ƒëi·ªán tho·∫°i khi ƒëang l√°i xe ·ªü \(String(format: "%.1f", currentSpeed)) km/h"
            )
        }
        
        print("üì± Device UNLOCKED at \(formatTime(unlockTime)) - Driving: \(isDriving), Speed: \(currentSpeed) km/h, InCall: \(isInCall), VoIPCall: \(isInVoIPCall)")
    }
    
    @objc func deviceDidLock() {
        isDeviceUnlocked = false
        
        let lockTime = Date()
        let lockData: [String: Any] = [
            "type": "LOCK_EVENT", 
            "message": "Thi·∫øt b·ªã v·ª´a b·ªã Kh√≥a",
            "location": formatTime(lockTime),
            "speed": currentSpeed,
            "isDriving": isDriving,
            "isInCall": isInCall,
            "isVoIPCall": isInVoIPCall,
            "timestamp": Int(lockTime.timeIntervalSince1970 * 1000)
        ]
        
        self.sendEventToFlutter(lockData)
        print("üîí Device LOCKED at \(formatTime(lockTime)) - Speed: \(currentSpeed) km/h, InCall: \(isInCall), VoIPCall: \(isInVoIPCall)")
    }
    
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("‚ùå Location Manager Error: \(error.localizedDescription)")
    }
    
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        print("üìç Location Authorization Changed: \(status.rawValue)")
        
        switch status {
        case .authorizedAlways, .authorizedWhenInUse:
            locationManager?.startUpdatingLocation()
        default:
            break
        }
    }
    
    // MARK: - Flutter Communication
    
    private func sendEventToFlutter(_ data: [String: Any]) {
        guard let eventSink = eventSink else { return }
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: data)
            if let jsonString = String(data: jsonData, encoding: .utf8) {
                eventSink(jsonString)
            }
        } catch {
            print("‚ùå L·ªói chuy·ªÉn ƒë·ªïi JSON: \(error)")
        }
    }
    
    // MARK: - Notifications
    
    private func sendCriticalNotification(title: String, message: String) {
        let content = UNMutableNotificationContent()
        content.title = title
        content.body = message
        content.sound = UNNotificationSound.defaultCritical
        
        if #available(iOS 15.0, *) {
            content.interruptionLevel = .critical
        }
        
        let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: nil)
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print("‚ùå L·ªói g·ª≠i th√¥ng b√°o critical: \(error.localizedDescription)")
            }
        }
    }
    
    // MARK: - Utility Methods
    
    private func formatTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm:ss"
        return formatter.string(from: date)
    }
}

// üéØ REAL NETWORK MONITOR V·ªöI NG∆Ø·ª†NG TH√îNG MINH
class RealNetworkMonitor {
    private var timer: Timer?
    private var lastNetworkStats: NetworkInterfaceStats?
    private var activitySamples: [Bool] = []
    private let sampleSize = 5
    private var consecutiveActiveCount = 0
    
    var onNetworkActivityDetected: ((Bool, String) -> Void)?
    
    func startMonitoring() {
        stopMonitoring()
        
        timer = Timer.scheduledTimer(withTimeInterval: 3.0, repeats: true) { [weak self] _ in
            self?.checkRealNetworkActivity()
        }
        
        if let timer = timer {
            RunLoop.current.add(timer, forMode: .common)
        }
        
        print("üåê Real Network Monitor started")
    }
    
    func stopMonitoring() {
        timer?.invalidate()
        timer = nil
    }
    
    func notifyLocationUpdate() {
        // Kh√¥ng c·∫ßn cooldown
    }
    
    private func checkRealNetworkActivity() {
        let currentStats = getCurrentNetworkStats()
        let isActive = detectRealNetworkActivity(currentStats: currentStats)
        let activityType = determineActivityType(currentStats: currentStats)
        
        // üéØ LOGIC X√ÅC NH·∫¨N TH√îNG MINH
        if isActive {
            consecutiveActiveCount += 1
        } else {
            consecutiveActiveCount = max(0, consecutiveActiveCount - 1)
        }
        
        // üéØ CH·ªà X√ÅC NH·∫¨N KHI C√ì 3 L·∫¶N ACTIVE LI√äN TI·∫æP
        let confirmedActive = consecutiveActiveCount >= 3
        
        DispatchQueue.main.async {
            self.onNetworkActivityDetected?(confirmedActive, activityType)
        }
        
        lastNetworkStats = currentStats
    }
    
    private func getCurrentNetworkStats() -> NetworkInterfaceStats {
        var stats = NetworkInterfaceStats()
        
        if let interfaceStats = getNetworkInterfaceStatistics() {
            stats.bytesReceived = interfaceStats.bytesReceived
            stats.bytesSent = interfaceStats.bytesSent
            stats.packetsReceived = interfaceStats.packetsReceived
            stats.hasActiveInterface = true
        }
        
        stats.activeConnections = getActiveURLSessionTasks()
        
        return stats
    }
    
    private func detectRealNetworkActivity(currentStats: NetworkInterfaceStats) -> Bool {
        guard let lastStats = lastNetworkStats else { return false }
        
        let receivedDiff = currentStats.bytesReceived - lastStats.bytesReceived
        let sentDiff = currentStats.bytesSent - lastStats.bytesSent
        let packetsDiff = currentStats.packetsReceived - lastStats.packetsReceived
        
        print("üåê Traffic Diff - Received: \(receivedDiff), Sent: \(sentDiff), Packets: \(packetsDiff)")
        
        // üéØ NG∆Ø·ª†NG TH√îNG MINH - PH√ô H·ª¢P WEB NH∆ØNG TR√ÅNH APP N·ªÄN
        let hasModerateDownload = receivedDiff > 80000    // 80KB - ƒë·ªß cho web c√≥ ·∫£nh
        let hasModerateUpload = sentDiff > 30000          // 30KB - ƒë·ªß cho form submit
        let hasPacketActivity = packetsDiff > 20          // 20 packets - traffic ƒë√°ng k·ªÉ
        let hasActiveConnections = currentStats.activeConnections > 3
        
        // üéØ K·∫æT H·ª¢P NHI·ªÄU Y·∫æU T·ªê ƒê·ªÇ TR√ÅNH B√ÅO ·∫¢O
        let isActive = (hasModerateDownload && hasPacketActivity) || 
                      (hasModerateUpload && hasPacketActivity) ||
                      (hasActiveConnections && hasModerateDownload) ||
                      (receivedDiff > 50000 && packetsDiff > 25) // Web nh·∫π nh∆∞ng nhi·ªÅu request
        
        print("üåê Network Activity Result: \(isActive) - Consecutive: \(consecutiveActiveCount)")
        return isActive
    }
    
    private func determineActivityType(currentStats: NetworkInterfaceStats) -> String {
        guard let lastStats = lastNetworkStats else { return "Kh√¥ng c√≥ d·ªØ li·ªáu" }
        
        let receivedDiff = currentStats.bytesReceived - lastStats.bytesReceived
        let sentDiff = currentStats.bytesSent - lastStats.bytesSent
        
        if receivedDiff > 150000 {
            return "T·∫£i d·ªØ li·ªáu l·ªõn (video/file)"
        } else if receivedDiff > 80000 {
            return "ƒêang xem web c√≥ ·∫£nh"
        } else if receivedDiff > 50000 {
            return "ƒêang l∆∞·ªõt web"
        } else if sentDiff > 30000 {
            return "ƒêang upload/g·ª≠i d·ªØ li·ªáu"
        } else {
            return "Ho·∫°t ƒë·ªông m·∫°ng nh·∫π"
        }
    }
    
    private func getNetworkInterfaceStatistics() -> (bytesReceived: Int, bytesSent: Int, packetsReceived: Int)? {
        var ifaddrs: UnsafeMutablePointer<ifaddrs>?
        guard getifaddrs(&ifaddrs) == 0 else { return nil }
        
        defer { freeifaddrs(ifaddrs) }
        
        var totalReceived: Int = 0
        var totalSent: Int = 0
        var totalPackets: Int = 0
        
        var pointer = ifaddrs
        while pointer != nil {
            defer { pointer = pointer?.pointee.ifa_next }
            
            guard let interface = pointer?.pointee else { continue }
            let name = String(cString: interface.ifa_name)
            
            if name.hasPrefix("en") || name.hasPrefix("pdp_ip") {
                if let data = interface.ifa_data {
                    let stats = data.withMemoryRebound(to: if_data.self, capacity: 1) { $0.pointee }
                    totalReceived += Int(stats.ifi_ibytes)
                    totalSent += Int(stats.ifi_obytes)
                    totalPackets += Int(stats.ifi_ipackets)
                }
            }
        }
        
        return (totalReceived, totalSent, totalPackets)
    }
    
    private func getActiveURLSessionTasks() -> Int {
        return 0
    }
}

struct NetworkInterfaceStats {
    var bytesReceived: Int = 0
    var bytesSent: Int = 0
    var packetsReceived: Int = 0
    var hasActiveInterface: Bool = false
    var activeConnections: Int = 0
}

// üéØ NETWORK CONGESTION DETECTOR
class NetworkCongestionDetector {
    private var pingTimer: Timer?
    
    var onNetworkStatusUpdate: ((Bool) -> Void)?
    
    func startMonitoring() {
        stopMonitoring()
        
        pingTimer = Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { [weak self] _ in
            self?.performNetworkAnalysis()
        }
    }
    
    func stopMonitoring() {
        pingTimer?.invalidate()
        pingTimer = nil
    }
    
    func setLocationUpdateCooldown() {
        // Kh√¥ng c·∫ßn cooldown
    }
    
    private func performNetworkAnalysis() {
        // ƒê∆°n gi·∫£n h√≥a, ch·ªß y·∫øu d·ª±a v√†o RealNetworkMonitor
        DispatchQueue.main.async {
            self.onNetworkStatusUpdate?(false)
        }
    }
}